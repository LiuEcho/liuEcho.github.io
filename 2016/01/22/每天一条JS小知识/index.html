

<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    
    <meta name="author" content="Liu Chang">
    
    <meta name="description" content="简介loverajoel/jstips是最近在github trending里很火的一个repo 。每天会分享一条javascript tip。我将其翻译成了中文版并把至今的所有tips贴了上来。希望对新手有所帮助小弟英语也很菜，翻译有误的地方欢迎大家指正或提交PR。
Tips List
20 - ">
    
    

    
    <link rel="alternative" href="YOUR_RSS_ADDRESS" title="Echo" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>每天一条JS小知识 | Echo</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script> 
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://liuecho.me" title="Echo">Echo</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/">首页</a></li>
                    
                    <li id="nav-archives"><a href="/archives">归档</a></li>
                    
                    <li id="nav-tags"><a href="/tags">标签</a></li>
                    
                    <li id="nav-categories"><a href="/categories">分类</a></li>
                    
                    <li id="nav-about"><a href="/about">关于</a></li>
                    
                    
                    <li><a href="https://github.com/liuecho" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/images/background/";
    var backArray = [ "1.jpg", "2.jpg", "3.jpg", "4.jpg", "5.jpg", "6.jpg", "7.jpg", "8.jpg",  ];
        
    $(function() {
        // page-id...
        var pageId = "2016/01/22/每天一条JS小知识/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>每天一条JS小知识</h1>
        
        <div class="time-info">
发表于:<time datetime="2016-01-22T01:42:12.000Z" itemprop="datePublished">2016-01-22</time>，更新于:<time datetime="2016-01-22T02:20:39.325Z" itemprop="dateModified">2016-01-22</time>，By <a href="http://liuecho.me" title="Liu Chang">Liu Chang</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">大纲</strong>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#u7B80_u4ECB"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20_-__u8FD4_u56DE_u5BF9_u8C61_uFF0C_u4F7F_u65B9_u6CD5_u53EF_u4EE5_u94FE_u5F0F_u8C03_u7528"><span class="toc-number">1.1.</span> <span class="toc-text">20 - 返回对象，使方法可以链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19_-__u5B89_u5168_u7684_u5B57_u7B26_u4E32_u62FC_u63A5"><span class="toc-number">1.2.</span> <span class="toc-text">19 - 安全的字符串拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18_-__u66F4_u5FEB_u7684_u53D6_u6574"><span class="toc-number">1.3.</span> <span class="toc-text">18 - 更快的取整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17_-_Node-js_3A__u8FD0_u884C_u672A_u88AB_u5F15_u7528_u7684_u6A21_u5757"><span class="toc-number">1.4.</span> <span class="toc-text">17 - Node.js: 运行未被引用的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16_-__u5411_u56DE_u8C03_u65B9_u6CD5_u4F20_u9012_u53C2_u6570"><span class="toc-number">1.5.</span> <span class="toc-text">16 - 向回调方法传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15_-__u66F4_u7B80_u5355_u7684_u4F7F_u7528indexOf_u5B9E_u73B0contains_u529F_u80FD"><span class="toc-number">1.6.</span> <span class="toc-text">15 - 更简单的使用indexOf实现contains功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14_-__u7BAD_u5934_u51FD_u6570__23ES6"><span class="toc-number">1.7.</span> <span class="toc-text">14 - 箭头函数 #ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13_-__u6D4B_u91CFjavascript_u4EE3_u7801_u5757_u6027_u80FD_u7684_u5C0F_u77E5_u8BC6"><span class="toc-number">1.8.</span> <span class="toc-text">13 - 测量javascript代码块性能的小知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12_-_ES6_u4E2D_u7684_u4F2A_u5F3A_u5236_u53C2_u6570__23ES6"><span class="toc-number">1.9.</span> <span class="toc-text">12 - ES6中的伪强制参数 #ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11_-__u53D8_u91CF_u63D0_u5347"><span class="toc-number">1.10.</span> <span class="toc-text">11 - 变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10_-__u68C0_u67E5_u67D0_u5BF9_u8C61_u662F_u5426_u6709_u67D0_u5C5E_u6027"><span class="toc-number">1.11.</span> <span class="toc-text">10 - 检查某对象是否有某属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09_-__u6A21_u677F_u5B57_u7B26_u4E32"><span class="toc-number">1.12.</span> <span class="toc-text">09 - 模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08_-__u5C06Node_List_u8F6C_u6362_u4E3A_u6570_u7EC4_28Array_29"><span class="toc-number">1.13.</span> <span class="toc-text">08 - 将Node List转换为数组(Array)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07_-__u201Cuse_strict_u201D__u53D8_u5F97_u61D2_u60F0"><span class="toc-number">1.14.</span> <span class="toc-text">07 - “use strict” 变得懒惰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06_-__u53EF_u4EE5_u63A5_u53D7_u5355_u5404_u53C2_u6570_u548C_u6570_u7EC4_u7684_u65B9_u6CD5"><span class="toc-number">1.15.</span> <span class="toc-text">06 - 可以接受单各参数和数组的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05_-_undefined_u4E0Enull_u7684_u533A_u522B"><span class="toc-number">1.16.</span> <span class="toc-text">05 - undefined与null的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2304_-__u6392_u5217_u5E26_u97F3_u8282_u5B57_u6BCD_u7684_u5B57_u7B26_u4E32_28_u539F_u6587_29"><span class="toc-number">1.17.</span> <span class="toc-text">#04 - 排列带音节字母的字符串(原文)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03_-__u4F18_u5316_u5D4C_u5957_u7684_u6761_u4EF6_u8BED_u53E5"><span class="toc-number">1.18.</span> <span class="toc-text">03 - 优化嵌套的条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0_-__u5411_u6570_u7EC4_u4E2D_u63D2_u5165_u5143_u7D20_28_u539F_u6587_29"><span class="toc-number">1.19.</span> <span class="toc-text">0 - 向数组中插入元素(原文)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">1.20.</span> <span class="toc-text">References</span></a></li></ol></li></ol>
            </div>
            
            <h1 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h1><p>loverajoel/jstips是最近在github trending里很火的一个repo 。每天会分享一条javascript tip。我将其翻译成了中文版并把至今的所有tips贴了上来。希望对新手有所帮助小弟英语也很菜，翻译有误的地方欢迎大家指正或提交PR。</p>
<p>Tips List</p>
<h2 id="20_-__u8FD4_u56DE_u5BF9_u8C61_uFF0C_u4F7F_u65B9_u6CD5_u53EF_u4EE5_u94FE_u5F0F_u8C03_u7528"><a href="#20_-__u8FD4_u56DE_u5BF9_u8C61_uFF0C_u4F7F_u65B9_u6CD5_u53EF_u4EE5_u94FE_u5F0F_u8C03_u7528" class="headerlink" title="20 - 返回对象，使方法可以链式调用"></a>20 - 返回对象，使方法可以链式调用</h2><pre><code>2016-01-20 by @WakeskaterX
</code></pre><p>在面向对象的Javascript中为对象建立一个方法时，返回当前对象可以让你在一条链上调用方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello my name is: "</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.changeName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"John"</span>);</span><br><span class="line">person.sayName().changeName(<span class="string">"Timmy"</span>).sayName();</span><br></pre></td></tr></table></figure></p>
<h2 id="19_-__u5B89_u5168_u7684_u5B57_u7B26_u4E32_u62FC_u63A5"><a href="#19_-__u5B89_u5168_u7684_u5B57_u7B26_u4E32_u62FC_u63A5" class="headerlink" title="19 - 安全的字符串拼接"></a>19 - 安全的字符串拼接</h2><pre><code>2016-01-19 by @gogainda
</code></pre><p>假如你需要拼接一些不确定类型的变量为字符串，你需要确保算术运算符在你拼接时不会起作用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> three = <span class="string">'3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>.concat(one, two, three); <span class="comment">//"123"</span></span><br></pre></td></tr></table></figure></p>
<p>这应该就是你所期望的拼接结果。如果不这样，拼接时加号可能会导致你意想不到的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> three = <span class="string">'3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = one + two + three; <span class="comment">//"33" instead of "123"</span></span><br></pre></td></tr></table></figure></p>
<p>关于性能,与用join来拼接字符串相比 concat的效率是几乎一样的。</p>
<p>你可以在MDN了解更多关于concat方法的内容。</p>
<h2 id="18_-__u66F4_u5FEB_u7684_u53D6_u6574"><a href="#18_-__u66F4_u5FEB_u7684_u53D6_u6574" class="headerlink" title="18 - 更快的取整"></a>18 - 更快的取整</h2><pre><code>2016-01-18 by pklinger
</code></pre><p>今天的小知识有关性能表现。曾经用过双波浪 ~~ 操作符吗? 有时候也称为双非(NOT)位操作. 你可以用它作为<code>Math.floor()</code>的替代方法。为什么会这样呢?</p>
<p>一个位操作符 ~ 将输入的32位的数字(input)转换为 -(input+1). 两个位操作符将输入(input)转变为 -(-(input + 1)+1) 是一个使结果趋向于0的取整好工具. 对于数字, 负数就像使用<code>Math.ceil()</code>方法而正数就像使用<code>Math.floor()</code>方法. 转换失败时,返回0,这在<code>Math.floor()</code>方法转换失败返回NaN时或许会派上用场。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个 ~</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">1337</span>)    <span class="comment">// -1338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字输入</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">47.11</span>)  <span class="comment">// -&gt; 47</span></span><br><span class="line"><span class="built_in">console</span>.log(~~-<span class="number">12.88</span>) <span class="comment">// -&gt; -12</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">1.9999</span>) <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">3</span>)      <span class="comment">// -&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换失败</span></span><br><span class="line"><span class="built_in">console</span>.log(~~[]) <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="literal">NaN</span>)  <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="literal">null</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于32位整数时转换失败</span></span><br><span class="line"><span class="built_in">console</span>.log(~~(<span class="number">2147483647</span> + <span class="number">1</span>) === (<span class="number">2147483647</span> + <span class="number">1</span>)) <span class="comment">// -&gt; 0</span></span><br></pre></td></tr></table></figure></p>
<p>虽然~~的性能更好,为了代码的可读性请用Math.floor().</p>
<h2 id="17_-_Node-js_3A__u8FD0_u884C_u672A_u88AB_u5F15_u7528_u7684_u6A21_u5757"><a href="#17_-_Node-js_3A__u8FD0_u884C_u672A_u88AB_u5F15_u7528_u7684_u6A21_u5757" class="headerlink" title="17 - Node.js: 运行未被引用的模块"></a>17 - Node.js: 运行未被引用的模块</h2><pre><code>2016-01-17 by @odsdq
</code></pre><p>在Node里,你可以让你的程序根据其运行自require(‘./something.js’)或者node something.js而做不同的处理。如果你想与你的一个独立的模块进行交互，这是非常有用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// 通过 `node something.js` 启动</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `require('/.something.js')` 被引用</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更多内容请看 modules的文档</p>
<h2 id="16_-__u5411_u56DE_u8C03_u65B9_u6CD5_u4F20_u9012_u53C2_u6570"><a href="#16_-__u5411_u56DE_u8C03_u65B9_u6CD5_u4F20_u9012_u53C2_u6570" class="headerlink" title="16 - 向回调方法传递参数"></a>16 - 向回调方法传递参数</h2><pre><code>2016-01-16 by @minhazav
</code></pre><p>通常下，你并不能给回调函数传递参数。 比如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi human'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, callback);</span><br></pre></td></tr></table></figure></p>
<p>你可以借助Javascript闭包的优势来传递参数给回调函数。看这个例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum = '</span>, (a+b));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, callback(x, y));</span><br></pre></td></tr></table></figure></p>
<p>什么是闭包?<br>闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。想了解更多请参考MDN的文档。</p>
<p>这种方法使参数x和y在回调方法被调用时处于其作用域内。</p>
<p>另一个办法是使用bind方法。比如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alertText = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  alert(text);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, alertText.bind(<span class="keyword">this</span>, <span class="string">'hello'</span>));</span><br></pre></td></tr></table></figure></p>
<p>两种方法之间有着微小的性能差异,请看jsperf.</p>
<h2 id="15_-__u66F4_u7B80_u5355_u7684_u4F7F_u7528indexOf_u5B9E_u73B0contains_u529F_u80FD"><a href="#15_-__u66F4_u7B80_u5355_u7684_u4F7F_u7528indexOf_u5B9E_u73B0contains_u529F_u80FD" class="headerlink" title="15 - 更简单的使用indexOf实现contains功能"></a>15 - 更简单的使用indexOf实现contains功能</h2><pre><code>2016-01-15 by @jhogoforbroke
</code></pre><p>JavaScript并未提供contains方法。检测子字符串是否存在于字符串或者变量是否存在于数组你可能会这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someText = <span class="string">'javascript rules'</span>;</span><br><span class="line"><span class="keyword">if</span> (someText.indexOf(<span class="string">'javascript'</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (someText.indexOf(<span class="string">'javascript'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是让我们看一下这些 Expressjs代码段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">examples/mvc/lib/boot.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="comment">// "reserved" exports</span></span><br><span class="line">  <span class="keyword">if</span> (~[<span class="string">'name'</span>, <span class="string">'prefix'</span>, <span class="string">'engine'</span>, <span class="string">'before'</span>].indexOf(key)) <span class="keyword">continue</span>;</span><br><span class="line">lib/utils.js</span><br><span class="line"></span><br><span class="line">exports.normalizeType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~type.indexOf(<span class="string">'/'</span>)</span><br><span class="line">    ? acceptParams(type)</span><br><span class="line">    : &#123; value: mime.lookup(type), params: &#123;&#125; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">examples/web-service/index.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// key is invalid</span></span><br><span class="line"><span class="keyword">if</span> (!~apiKeys.indexOf(key)) <span class="keyword">return</span> next(error(<span class="number">401</span>, <span class="string">'invalid api key'</span>));</span><br></pre></td></tr></table></figure></p>
<p>难点是 位操作符 ~, “按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。”</p>
<p>它将-1转换为0,而0在javascript为false,所以:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someText = <span class="string">'text'</span>;</span><br><span class="line">!!~someText.indexOf(<span class="string">'tex'</span>); <span class="comment">// someText contains "tex" - true</span></span><br><span class="line">!~someText.indexOf(<span class="string">'tex'</span>); <span class="comment">// someText NOT contains "tex" - false</span></span><br><span class="line">~someText.indexOf(<span class="string">'asd'</span>); <span class="comment">// someText doesn't contain "asd" - false</span></span><br><span class="line">~someText.indexOf(<span class="string">'ext'</span>); <span class="comment">// someText contains "ext" - true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.includes()</span><br></pre></td></tr></table></figure></p>
<p>在ES6中提供了includes() 方法供我们判断一个字符串是否包含了另一个字符串:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'something'</span>.includes(<span class="string">'thing'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>在ECMAScript 2016 (ES7)甚至可能将其应用于数组，像indexOf一样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!~[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>不幸的是, 只有Chrome、Firefox、Safari 9及其更高版本和Edge支持了这功能。IE11及其更低版本并不支持<br>最好在受控的环境中使用此功能</p>
<h2 id="14_-__u7BAD_u5934_u51FD_u6570__23ES6"><a href="#14_-__u7BAD_u5934_u51FD_u6570__23ES6" class="headerlink" title="14 - 箭头函数 #ES6"></a>14 - 箭头函数 #ES6</h2><pre><code>2016-01-13 by @pklinger
</code></pre><p>介绍一个ES6的新特性，箭头函数或许一个让你用更少行写更多代码的方便工具。它的名字(fat arrow functions)来自于它的语法=&gt;是一个比瘦箭头-&gt;要’胖的箭头’（译者注：但是国内貌似不分胖瘦就叫箭头函数）。Some programmers might already know this type of functions from different languages such as Haskell as ‘lambda expressions’ respectively ‘anonymous functions’. It is called anonymous, as these arrow functions do not have a descriptive function name.（译者注：一些其他语言中的箭头函数，避免不准确就不翻译了）</p>
<p>有什么益处呢?</p>
<p>语法: 更少的代码行; 不再需要一遍一遍的打function了<br>语义: 从上下文中捕获this关键字<br>简单的语法示例</p>
<p>观察一下这两个功能完全相同的代码片段。你将很快明白箭头函数做了什么。</p>
<p>// 箭头函数的一般语法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param =&gt; expression</span><br></pre></td></tr></table></figure></p>
<p>// 也可以用用小括号<br>// 多参数时小括号是必须的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1 [, param2]) =&gt; expression</span><br></pre></td></tr></table></figure></p>
<p>// 使用functions<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></p>
<p>// 使用箭头函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map((x) =&gt; x*x);</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></p>
<p>正如你所看到的，箭头函数在这种情况下省去了写小括号，function以及return的时间。我建议你总是使用小括号，因为对于像(x,y) =&gt; x+y这样多参数函数，小括号总是需要的。这仅是以防在不同使用场景下忘记小括号的一种方法。但是上面的代码和x =&gt; x*x是一样的。至此仅是语法上的提升，减少了代码行数并提高了可读性。</p>
<pre><code>Lexically binding this
</code></pre><p>这是另一个使用箭头函数的好原因。这是一个关于this上下文的问题。使用箭头函数，你不需要再担心.bind(this)也不用再设置that = this了，因为箭头函数继承了外围作用域的this值。看一下下面的示例:<br>// 全局定义 this.i<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counterA = <span class="keyword">new</span> CounterA();</span><br><span class="line"><span class="keyword">var</span> counterB = <span class="keyword">new</span> CounterB();</span><br><span class="line"><span class="keyword">var</span> counterC = <span class="keyword">new</span> CounterC();</span><br><span class="line"><span class="keyword">var</span> counterD = <span class="keyword">new</span> CounterD();</span><br></pre></td></tr></table></figure></p>
<p>// 不好的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// CounterA的`this`实例 (!!调用时忽略了此实例)</span></span><br><span class="line">  <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向全局(global)对象,而不是CounterA的`this`</span></span><br><span class="line">    <span class="comment">// 所以从100开始计数,而不是0 (本地的this.i)</span></span><br><span class="line">    <span class="keyword">this</span>.i++;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"counterA"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// 手动绑定 that = this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.i++;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"counterB"</span>).innerHTML = that.i;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// 使用 .bind(this)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.i++;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"counterC"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>), <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// 箭头函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.i++;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"counterD"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更多有关箭头函数的内容可以查看MDN。更多语法选项请看这里.</p>
<h2 id="13_-__u6D4B_u91CFjavascript_u4EE3_u7801_u5757_u6027_u80FD_u7684_u5C0F_u77E5_u8BC6"><a href="#13_-__u6D4B_u91CFjavascript_u4EE3_u7801_u5757_u6027_u80FD_u7684_u5C0F_u77E5_u8BC6" class="headerlink" title="13 - 测量javascript代码块性能的小知识"></a>13 - 测量javascript代码块性能的小知识</h2><pre><code>2016-01-13 by @manmadareddy
</code></pre><p>快速的测量javascript的性能，我们可以使用console的方法，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(label) 和 <span class="built_in">console</span>.timeEnd(label)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"Array initialize"</span>);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>),</span><br><span class="line">    len = arr.length,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array initialize"</span>); <span class="comment">// Outputs: Array initialize: 0.711ms</span></span><br></pre></td></tr></table></figure></p>
<p>更多内容:<br>Console object,<br>Javascript benchmarking</p>
<p>Demo: jsfiddle - codepen (在浏览器控制台输出)</p>
<h2 id="12_-_ES6_u4E2D_u7684_u4F2A_u5F3A_u5236_u53C2_u6570__23ES6"><a href="#12_-_ES6_u4E2D_u7684_u4F2A_u5F3A_u5236_u53C2_u6570__23ES6" class="headerlink" title="12 - ES6中的伪强制参数 #ES6"></a>12 - ES6中的伪强制参数 #ES6</h2><pre><code>2016-01-12 by Avraam Mavridis
</code></pre><p>在许多编程语言中，方法的参数时默认强制需要的，开发人员需要明确定义一个可选的参数。在Javascript中任何参数都是可选的，但是我们可以利用es6参数默认值特性的优点来实现强制要求这种表现而不污染本身的函数体。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _err = <span class="function"><span class="keyword">function</span>(<span class="params"> message </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( message );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSum = (a = _err(<span class="string">'a is not defined'</span>), b = _err(<span class="string">'b is not defined'</span>)) =&gt; a + b</span><br><span class="line"></span><br><span class="line">getSum( <span class="number">10</span> ) <span class="comment">// throws Error, b is not defined</span></span><br><span class="line">getSum( <span class="literal">undefined</span>, <span class="number">10</span> ) <span class="comment">// throws Error, a is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>_err方法会立即抛出一个错误。如果没有传递值给参数，默认值将会被使用, _err方法将被调用而错误也将被抛出。你可以从MDN看到更多关于默认参数特性的例子。</p>
<h2 id="11_-__u53D8_u91CF_u63D0_u5347"><a href="#11_-__u53D8_u91CF_u63D0_u5347" class="headerlink" title="11 - 变量提升"></a>11 - 变量提升</h2><pre><code>2016-01-11 by @squizzleflip
</code></pre><p>了解变量提升可以帮助你组织方法作用域。只要记住变量生命和方法生命都会被提升到顶部。变量的定义不会提升，即使你在同一行声明和定义一个变量。变量声明是让系统知道有这个变量存在而定义是给其赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTheThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ReferenceError: notDeclared is not defined</span></span><br><span class="line">  <span class="built_in">console</span>.log(notDeclared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Outputs: undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(definedLater);</span><br><span class="line">  <span class="keyword">var</span> definedLater;</span><br><span class="line"></span><br><span class="line">  definedLater = <span class="string">'I am defined!'</span></span><br><span class="line">  <span class="comment">// Outputs: 'I am defined!'</span></span><br><span class="line">  <span class="built_in">console</span>.log(definedLater)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Outputs: undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(definedSimulateneously);</span><br><span class="line">  <span class="keyword">var</span> definedSimulateneously = <span class="string">'I am defined!'</span></span><br><span class="line">  <span class="comment">// Outputs: 'I am defined!'</span></span><br><span class="line">  <span class="built_in">console</span>.log(definedSimulateneously)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Outputs: 'I did it!'</span></span><br><span class="line">  doSomethingElse();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I did it!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">  functionVar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> functionVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I did it!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了让你的代码更易读，将所有的变量声明在函数的顶端，这样可以更清楚的知道变量来自哪个作用域。在使用变量之前声明变量。将方法定义在函数的底部。</p>
<h2 id="10_-__u68C0_u67E5_u67D0_u5BF9_u8C61_u662F_u5426_u6709_u67D0_u5C5E_u6027"><a href="#10_-__u68C0_u67E5_u67D0_u5BF9_u8C61_u662F_u5426_u6709_u67D0_u5C5E_u6027" class="headerlink" title="10 - 检查某对象是否有某属性"></a>10 - 检查某对象是否有某属性</h2><pre><code>2016-01-10 by @loverajoel
</code></pre><p>当你需要检查某属性是否存在于一个对象，你可能会这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">'[@tips_js](/user/tips_js)'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myObject.name) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是可以的，但是你需要知道有两种原生方法可以解决此类问题。in 操作符 和 Object.hasOwnProperty，任何继承自Object的对象都可以使用这两种方法。</p>
<p>看一下较大的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">'[@tips_js](/user/tips_js)'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> myObject; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'valueOf'</span>); <span class="comment">// false, valueOf 继承自原型链</span></span><br><span class="line"><span class="string">'valueOf'</span> <span class="keyword">in</span> myObject; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>两者检查属性的深度不同，换言之hasOwnProperty只在本身有此属性时返回true,而in操作符不区分属性来自于本身或继承自原型链。</p>
<p>这是另一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'[@tips_js](/user/tips_js)'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myFunc.prototype.age = <span class="string">'10 days'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> myFunc();</span><br><span class="line"></span><br><span class="line">user.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">user.hasOwnProperty(<span class="string">'age'</span>); <span class="comment">// false, 因为age来自于原型链</span></span><br></pre></td></tr></table></figure></p>
<p>在线示例!</p>
<p>同样建议阅读关于检查对象是否包含属性时常见错误的讨论。</p>
<h2 id="09_-__u6A21_u677F_u5B57_u7B26_u4E32"><a href="#09_-__u6A21_u677F_u5B57_u7B26_u4E32" class="headerlink" title="09 - 模板字符串"></a>09 - 模板字符串</h2><pre><code>2016-01-09 by @JakeRawr(原文)
</code></pre><p>ES6中，JS现在有了引号拼接字符串的替代品，模板字符串。</p>
<p>示例:<br>普通字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Jake'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Rawr'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'My name is '</span> + firstName + <span class="string">' '</span> + lastName);</span><br><span class="line"><span class="comment">// My name is Jake Rawr</span></span><br><span class="line">模板字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Jake'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Rawr'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// My name is Jake Rawr</span></span><br></pre></td></tr></table></figure></p>
<p>在模板字符串中，你可以不用\n来生成多行字符串还可以在${}里做简单的逻辑运算（例如 2+3）。</p>
<p>你也可以使用方法修改模板字符串的输出内容；他们被称为带标签的模板字符串（其中有带标签的模板字符串的示例）</p>
<p>或许你还想阅读更多内容来了解模板字符串。</p>
<h2 id="08_-__u5C06Node_List_u8F6C_u6362_u4E3A_u6570_u7EC4_28Array_29"><a href="#08_-__u5C06Node_List_u8F6C_u6362_u4E3A_u6570_u7EC4_28Array_29" class="headerlink" title="08 - 将Node List转换为数组(Array)"></a>08 - 将Node List转换为数组(Array)</h2><pre><code>2016-01-08 by @Tevko
</code></pre><p>querySelectorAll方法返回一个类数组对象称为node list。这些数据结构被称为“类数组”，因为他们看似数组却没有类似map、foreach这样的数组方法。这是一个快速、安全、可重用的方法将node list转换为DOM元素的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodelist = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">const</span> nodelistToArray = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, nodelist);</span><br><span class="line"><span class="comment">//之后 ..</span></span><br><span class="line">nodelistToArray.forEach(...);</span><br><span class="line">nodelistToArray.map(...);</span><br><span class="line">nodelistToArray.slice(...);</span><br><span class="line"><span class="comment">//等...</span></span><br></pre></td></tr></table></figure></p>
<p>apply方法可以在指定this时以数组形式向方法传递参数。MDN规定apply可以接受类数组对象,恰巧就是querySelectorAll方法所返回的内容。如果我们不需要指定方法内this的值传null或0即可。返回的结果即包含所有数组方法的DOM元素数组。</p>
<p>如果你正在用ES2015你可以使用展开运算符 …<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodelist = [...document.querySelectorAll(<span class="string">'div'</span>)]; <span class="comment">// 返回一个真正的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后 ..</span></span><br><span class="line"></span><br><span class="line">nodelist.forEach(...);</span><br><span class="line">nodelist.map(...);</span><br><span class="line">nodelist.slice(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="07_-__u201Cuse_strict_u201D__u53D8_u5F97_u61D2_u60F0"><a href="#07_-__u201Cuse_strict_u201D__u53D8_u5F97_u61D2_u60F0" class="headerlink" title="07 - “use strict” 变得懒惰"></a>07 - “use strict” 变得懒惰</h2><pre><code>2016-01-07 by @nainslie
</code></pre><p>（译者注：此片翻译较渣，欢迎指正，建议大家阅读原文或直接阅读MDN对严格模式的中文介绍）<br>JavaScript的严格模式使开发者更容易写出“安全”的代码。</p>
<p>通常情况下，JavaScript允许程序员相当粗心，比如你可以引用一个从未用”var”声明的变量。或许对于一个刚入门的开发者来说这看起来很方便，但这也是变量拼写错误或者从作用域外引用变量时引发的一系列错误的原因。</p>
<p>程序员喜欢电脑帮我们做一些无聊的工作，喜欢它自动的检查我们工作上的错误。这就是”use strict”帮我们做的，它把我们的错误转变为了JavaScript错误。</p>
<p>我们把这个指令放在js文件顶端来使用它:</p>
<p>// 全脚本严格模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> v = <span class="string">"Hi!  I'm a strict mode script!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>或者放在一个方法内：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 方法级严格模式</span></span><br><span class="line"><span class="pi">  'use strict'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"And so am I!"</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi!  I'm a strict mode function!  "</span> + nested();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"I'm not strict."</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过在JavaScript文件或方法内引入此指令，使JavaScript引擎运行在严格模式下，这直接禁止了许多大项目中不受欢迎的操作。另外，严格模式也改变了以下行为：</p>
<blockquote>
<p>1.只有被”var”声明过的变量才可以引用。<br>2.试图写只读变量时将会报错<br>3.只能通过”new”关键字调用构造方法<br>4.”this”不再隐式的指向全局变量<br>5.对eval()有更严格的限制<br>6.防止你使用预保留关键字命名变量</p>
</blockquote>
<p>严格模式对于新项目来说是很棒的，但对于一些并没有使用它的老项目来说，引入它也是很有挑战性的。如果你把所有js文件都连接到一个大文件中的话，可能导致所有文件都运行在严格模式下，这可能也会有一些问题。</p>
<p>It is not a statement, but a literal expression, ignored by earlier versions of JavaScript.<br>严格模式的支持情况:</p>
<pre><code>Internet Explorer from version 10.
Firefox from version 4.
Chrome from version 13.
Safari from version 5.1.
Opera from version 12.
</code></pre><p>MDN对严格模式的全面介绍</p>
<h2 id="06_-__u53EF_u4EE5_u63A5_u53D7_u5355_u5404_u53C2_u6570_u548C_u6570_u7EC4_u7684_u65B9_u6CD5"><a href="#06_-__u53EF_u4EE5_u63A5_u53D7_u5355_u5404_u53C2_u6570_u548C_u6570_u7EC4_u7684_u65B9_u6CD5" class="headerlink" title="06 - 可以接受单各参数和数组的方法"></a>06 - 可以接受单各参数和数组的方法</h2><pre><code>2016-01-06 by @mattfxyz(原文)
</code></pre><p>写一个方法可以接受单个参数也可以接受一个数组，而不是分开写两个方法。这和jQuery的一些方法的工作原理很像(css 可以修改任何匹配到的选择器).</p>
<p>你只要把任何东西连接到一个数组. Array.concat可以接受一个数组也可以接受单个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printUpperCase</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elements = [].concat(words);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elements[i].toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>printUpperCase现在可以接受单个单词或多个单词的数组作为它的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printUpperCase(<span class="string">"cactus"</span>);</span><br><span class="line"><span class="comment">// =&gt; CACTUS</span></span><br><span class="line">printUpperCase([<span class="string">"cactus"</span>, <span class="string">"bear"</span>, <span class="string">"potato"</span>]);</span><br><span class="line"><span class="comment">// =&gt; CACTUS</span></span><br><span class="line"><span class="comment">//  BEAR</span></span><br><span class="line"><span class="comment">//  POTATO</span></span><br></pre></td></tr></table></figure></p>
<h2 id="05_-_undefined_u4E0Enull_u7684_u533A_u522B"><a href="#05_-_undefined_u4E0Enull_u7684_u533A_u522B" class="headerlink" title="05 - undefined与null的区别"></a>05 - undefined与null的区别</h2><pre><code>2016-01-05 by @loverajoel
</code></pre><p>undefined表示一个变量没有被声明，或者被声明了但没有被赋值</p>
<p>null是一个表示“没有值”的值</p>
<p>Javascript将未赋值的变量默认值设为undefined</p>
<p>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</p>
<p>undefined不是一个有效的JSON而null是</p>
<p>undefined的类型(typeof)是undefined</p>
<p>null的类型(typeof)是object. 为什么?</p>
<p>它们都是基本类型</p>
<p>他们都是falsy<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false, Boolean(null) // false)</span></span><br></pre></td></tr></table></figure></p>
<p>你可以这样判断一个变量是否是undefined<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> variable === <span class="string">"undefined"</span></span><br><span class="line">  variable === <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<p>双等号比较时它们相等，但三等号比较时不相等</p>
<pre><code>null == undefined // true

null === undefined // false
</code></pre><h2 id="2304_-__u6392_u5217_u5E26_u97F3_u8282_u5B57_u6BCD_u7684_u5B57_u7B26_u4E32_28_u539F_u6587_29"><a href="#2304_-__u6392_u5217_u5E26_u97F3_u8282_u5B57_u6BCD_u7684_u5B57_u7B26_u4E32_28_u539F_u6587_29" class="headerlink" title="#04 - 排列带音节字母的字符串(原文)"></a>#04 - 排列带音节字母的字符串(<a href="https://github.com/loverajoel/jstips#04---sorting-strings-with-accented-characters" target="_blank" rel="external">原文</a>)</h2><blockquote>
<p>2016-01-04 by <a href="https://twitter.com/loverajoel" target="_blank" rel="external">@loverajoel</a></p>
</blockquote>
<p>Javascript有一个原生方法<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="external">sort</a></strong>可以排列数组。一次简单的<code>array.sort()</code>将每一个数组元素视为字符串并按照字母表排列。你也可以提供<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters" target="_blank" rel="external">自定义排列方法</a> function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Shanghai'</span>, <span class="string">'New York'</span>, <span class="string">'Mumbai'</span>, <span class="string">'Buenos Aires'</span>].sort();</span><br><span class="line"><span class="comment">// ["Buenos Aires", "Mumbai", "New York", "Shanghai"]</span></span><br></pre></td></tr></table></figure>
<p>但是当你试图整理一个如[‘é’, ‘a’, ‘ú’, ‘c’]这样的非ASCII元素的数组时，你可能会得到一个奇怪的结果[‘c’, ‘e’, ‘á’, ‘ú’]。这是因为排序方法只在英文下有用。</p>
<p>看一下下一个例子:</p>
<p>// 西班牙语<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'único'</span>,<span class="string">'árbol'</span>, <span class="string">'cosas'</span>, <span class="string">'fútbol'</span>].sort();</span><br><span class="line"><span class="comment">// ["cosas", "fútbol", "árbol", "único"] // bad order</span></span><br></pre></td></tr></table></figure></p>
<p>// 德语<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Woche'</span>, <span class="string">'wöchentlich'</span>, <span class="string">'wäre'</span>, <span class="string">'Wann'</span>].sort();</span><br><span class="line"><span class="comment">// ["Wann", "Woche", "wäre", "wöchentlich"] // bad order</span></span><br></pre></td></tr></table></figure></p>
<p>幸运的是，有两种方法可以解决这个问题，由ECMAScript国际化API提供的localeCompare和Intl.Collator。</p>
<p> 两个方法都有自定义配置参数可以使其更好用。</p>
<p>使用localeCompare()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'único'</span>,<span class="string">'árbol'</span>, <span class="string">'cosas'</span>, <span class="string">'fútbol'</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ["árbol", "cosas", "fútbol", "único"]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'Woche'</span>, <span class="string">'wöchentlich'</span>, <span class="string">'wäre'</span>, <span class="string">'Wann'</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ["Wann", "wäre", "Woche", "wöchentlich"]</span></span><br><span class="line">使用<span class="built_in">Intl</span>.Collator()</span><br><span class="line"></span><br><span class="line">[<span class="string">'único'</span>,<span class="string">'árbol'</span>, <span class="string">'cosas'</span>, <span class="string">'fútbol'</span>].sort(<span class="built_in">Intl</span>.Collator().compare);</span><br><span class="line"><span class="comment">// ["árbol", "cosas", "fútbol", "único"]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'Woche'</span>, <span class="string">'wöchentlich'</span>, <span class="string">'wäre'</span>, <span class="string">'Wann'</span>].sort(<span class="built_in">Intl</span>.Collator().compare);</span><br><span class="line"><span class="comment">// ["Wann", "wäre", "Woche", "wöchentlich"]</span></span><br></pre></td></tr></table></figure></p>
<p>两个方法都可以自定义区域位置。For each method you can customize the location.<br>根据Firefox，当比较大数量的字符串是Intl.Collator更快。<br>所以当你处理一个由非英语组成的字符串数组时，记得使用此方法来避免排序出现意外。</p>
<h2 id="03_-__u4F18_u5316_u5D4C_u5957_u7684_u6761_u4EF6_u8BED_u53E5"><a href="#03_-__u4F18_u5316_u5D4C_u5957_u7684_u6761_u4EF6_u8BED_u53E5" class="headerlink" title="03 - 优化嵌套的条件语句"></a>03 - 优化嵌套的条件语句</h2><pre><code>2016-01-03 by AlbertoFuente
</code></pre><p>我们怎样来提高和优化javascript里嵌套的if语句呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (color) &#123;</span><br><span class="line">  <span class="keyword">if</span> (color === <span class="string">'black'</span>) &#123;</span><br><span class="line">    printBlackBackground();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">'red'</span>) &#123;</span><br><span class="line">    printRedBackground();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    printBlueBackground();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">'green'</span>) &#123;</span><br><span class="line">    printGreenBackground();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printYellowBackground();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种方法来提高嵌套的if语句是用switch语句。虽然它不那么啰嗦而且排列整齐，但是并不建议使用它，因为这对于调试错误很困难。这告诉你为什么.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(color) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'black'</span>:</span><br><span class="line">    printBlackBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'red'</span>:</span><br><span class="line">    printRedBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'blue'</span>:</span><br><span class="line">    printBlueBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'green'</span>:</span><br><span class="line">    printGreenBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    printYellowBackground();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果在每个语句中都有很多条件检查时该怎么办呢？这种情况下，如果我们想要不罗嗦又整洁的话，我们可以用有条件的switch。如果我们传递true给switch语句，我没变可以在每个case中使用条件语句了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">typeof</span> color === <span class="string">'string'</span> &amp;&amp; color === <span class="string">'black'</span>):</span><br><span class="line">    printBlackBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">typeof</span> color === <span class="string">'string'</span> &amp;&amp; color === <span class="string">'red'</span>):</span><br><span class="line">    printRedBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">typeof</span> color === <span class="string">'string'</span> &amp;&amp; color === <span class="string">'blue'</span>):</span><br><span class="line">    printBlueBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">typeof</span> color === <span class="string">'string'</span> &amp;&amp; color === <span class="string">'green'</span>):</span><br><span class="line">    printGreenBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">typeof</span> color === <span class="string">'string'</span> &amp;&amp; color === <span class="string">'yellow'</span>):</span><br><span class="line">    printYellowBackground();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是我们应该时刻注意避免太多判断在一个条件里，尽量少的使用switch，考虑最有效率的方法：借助object。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorObj = &#123;</span><br><span class="line">  <span class="string">'black'</span>: printBlackBackground,</span><br><span class="line">  <span class="string">'red'</span>: printRedBackground,</span><br><span class="line">  <span class="string">'blue'</span>: printBlueBackground,</span><br><span class="line">  <span class="string">'green'</span>: printGreenBackground,</span><br><span class="line">  <span class="string">'yellow'</span>: printYellowBackground</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (color <span class="keyword">in</span> colorObj) &#123;</span><br><span class="line">  colorObj[color]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="0_-__u5411_u6570_u7EC4_u4E2D_u63D2_u5165_u5143_u7D20_28_u539F_u6587_29"><a href="#0_-__u5411_u6570_u7EC4_u4E2D_u63D2_u5165_u5143_u7D20_28_u539F_u6587_29" class="headerlink" title="0 - 向数组中插入元素(原文)"></a>0 - 向数组中插入元素(原文)</h2><p> 2015-12-29</p>
<p>向一个数组中插入元素是平时很常见的一件事情。你可以使用push在数组尾部插入元素,可以用unshift在数组头部插入元素,也可以用splice在数组中间插入元素。</p>
<p>但是这些已知的方法，并不意味着没有更加高效的方法。让我们接着往下看……</p>
<p>向数组结尾添加元素用push()很简单，但下面有一个更高效的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">6</span>);</span><br><span class="line">arr[arr.length] = <span class="number">6</span>; <span class="comment">// 在Mac OS X 10.11.1下的Chrome 47.0.2526.106中快43%</span></span><br></pre></td></tr></table></figure></p>
<p>两种方法都是修改原始数组。不信？看看jsperf</p>
<p>现在我们试着向数组的头部添加元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.unshift(<span class="number">0</span>);</span><br><span class="line">[<span class="number">0</span>].concat(arr); <span class="comment">// 在Mac OS X 10.11.1下的Chrome 47.0.2526.106中快98%</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一些小区别，unshift操作的是原始数组，concat返回一个新数组，参考jsperf</p>
<p>使用splice可以简单的向数组总监添加元素，这也是最高效的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line">items.splice(items.length / <span class="number">2</span>, <span class="number">0</span>, <span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure></p>
<p>我在许多浏览器和系统中进行了测试，结果都是相似的。希望这条小知识可以帮到你，也欢迎大家自行测试。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>转自<a href="https://cnodejs.org/topic/56a050ac8392272262331d62" target="_blank" rel="external">每天一条JS小知识(jstips中文翻译)</a></p>


			
            <section class="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2016/01/22/每天一条JS小知识/" data-title="每天一条JS小知识" data-url="http://liuecho.me/2016/01/22/每天一条JS小知识/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"liuecho"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
        </div>
    </div>
</article>

    <footer id="footer">
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a> 主题</small><br />
        <small>&copy; 2016 Liu Chang</small>
    </footer>
    


</body>
</html>

